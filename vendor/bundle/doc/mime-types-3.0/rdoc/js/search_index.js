var search_data = {"index":{"searchIndex":["mime","type","columnar","invalidcontenttype","invalidencoding","types","mime::types::cache","columnar","container","loader","warnlogger","warnlogdevice","<=>()","[]()","[]()","__instances__()","__types__()","add()","add()","add_extensions()","add_type()","add_type_variant!()","arr()","ascii?()","binary?()","columnar_path()","complete?()","content_type=()","count()","count()","default_encoding()","dict()","each()","each()","each_file_line()","encode_with()","eql?()","extensions()","flag()","friendly()","i18n_key()","index_extensions!()","init_with()","json_path()","lazy_load?()","like?()","load()","load()","load()","load_columnar()","load_default_mime_types()","load_docs()","load_encoding()","load_flags()","load_friendly()","load_from_json()","load_from_yaml()","load_json()","load_mode()","load_preferred_extension()","load_use_instead()","load_xrefs()","load_yaml()","match()","match()","new()","new()","new()","of()","of()","opt()","priority_compare()","prune_matches()","read_file()","reindex_extensions()","reindex_extensions!()","save()","simplified()","simplify_matchdata()","to_h()","to_json()","to_s()","to_str()","type_for()","type_for()","xref_map()","xref_url_for_draft()","xref_url_for_person()","xref_url_for_rfc()","xref_url_for_rfc_errata()","xref_url_for_template()","xref_urls()","yaml_path()","code-of-conduct","contributing","history","licence","manifest","readme"],"longSearchIndex":["mime","mime::type","mime::type::columnar","mime::type::invalidcontenttype","mime::type::invalidencoding","mime::types","mime::types::cache","mime::types::columnar","mime::types::container","mime::types::loader","mime::types::warnlogger","mime::types::warnlogger::warnlogdevice","mime::type#<=>()","mime::types#[]()","mime::types::[]()","mime::types::__instances__()","mime::types::__types__()","mime::types::add()","mime::types#add()","mime::type#add_extensions()","mime::types#add_type()","mime::types#add_type_variant!()","mime::types::columnar#arr()","mime::type#ascii?()","mime::type#binary?()","mime::types::loader#columnar_path()","mime::type#complete?()","mime::type#content_type=()","mime::types#count()","mime::types::count()","mime::type#default_encoding()","mime::types::columnar#dict()","mime::types::each()","mime::types#each()","mime::types::columnar#each_file_line()","mime::type#encode_with()","mime::type#eql?()","mime::type#extensions()","mime::types::columnar#flag()","mime::type#friendly()","mime::type::i18n_key()","mime::types#index_extensions!()","mime::type#init_with()","mime::types::loader#json_path()","mime::types::lazy_load?()","mime::type#like?()","mime::types::cache::load()","mime::types::loader#load()","mime::types::loader::load()","mime::types::loader#load_columnar()","mime::types::load_default_mime_types()","mime::types::columnar#load_docs()","mime::types::columnar#load_encoding()","mime::types::columnar#load_flags()","mime::types::columnar#load_friendly()","mime::types::loader::load_from_json()","mime::types::loader::load_from_yaml()","mime::types::loader#load_json()","mime::types::load_mode()","mime::types::columnar#load_preferred_extension()","mime::types::columnar#load_use_instead()","mime::types::columnar#load_xrefs()","mime::types::loader#load_yaml()","mime::type::match()","mime::types#match()","mime::type::new()","mime::types::new()","mime::types::loader::new()","mime::types#of()","mime::types::of()","mime::types::columnar#opt()","mime::type#priority_compare()","mime::types#prune_matches()","mime::types::loader::read_file()","mime::types::reindex_extensions()","mime::types#reindex_extensions!()","mime::types::cache::save()","mime::type::simplified()","mime::type::simplify_matchdata()","mime::type#to_h()","mime::type#to_json()","mime::type#to_s()","mime::type#to_str()","mime::types::type_for()","mime::types#type_for()","mime::type#xref_map()","mime::type#xref_url_for_draft()","mime::type#xref_url_for_person()","mime::type#xref_url_for_rfc()","mime::type#xref_url_for_rfc_errata()","mime::type#xref_url_for_template()","mime::type#xref_urls()","mime::types::loader#yaml_path()","","","","","",""],"info":[["MIME","","MIME.html","","<p>The namespace for MIME applications, tools, and libraries.\n"],["MIME::Type","","MIME/Type.html","","<p>The definition of one MIME content-type.\n<p>Usage\n\n<pre>require &#39;mime/types&#39;\n\nplaintext = MIME::Types[&#39;text/plain&#39;].first ...</pre>\n"],["MIME::Type::Columnar","","MIME/Type/Columnar.html","","<p>A version of MIME::Type that works hand-in-hand with a\nMIME::Types::Columnar container to load data by …\n"],["MIME::Type::InvalidContentType","","MIME/Type/InvalidContentType.html","","<p>Reflects a MIME content-type specification that is not correctly formatted\n(it isn&#39;t <code>type</code>/<code>subtype</code> …\n"],["MIME::Type::InvalidEncoding","","MIME/Type/InvalidEncoding.html","","<p>Reflects an unsupported MIME encoding.\n"],["MIME::Types","","MIME/Types.html","","<p>MIME::Types is a registry of MIME types. It is both a class (created with\nMIME::Types.new) and a default …\n"],["MIME::Types::Cache","","MIME/Types/Cache.html","","<p>Caching of MIME::Types registries is advisable if you will be loading the\ndefault registry relatively …\n"],["MIME::Types::Columnar","","MIME/Types/Columnar.html","","<p>MIME::Types::Columnar is used to extend a MIME::Types container to load\ndata by columns instead of from …\n"],["MIME::Types::Container","","MIME/Types/Container.html","",""],["MIME::Types::Loader","","MIME/Types/Loader.html","","<p>This class is responsible for initializing the MIME::Types registry from\nthe data files supplied with …\n"],["MIME::Types::WarnLogger","","MIME/Types/WarnLogger.html","",""],["MIME::Types::WarnLogger::WarnLogDevice","","MIME/Types/WarnLogger/WarnLogDevice.html","",""],["<=>","MIME::Type","MIME/Type.html#method-i-3C-3D-3E","(other)","<p>Compares the <code>other</code> MIME::Type against the exact content type\nor the simplified type (the simplified type …\n"],["[]","MIME::Types","MIME/Types.html#method-i-5B-5D","(type_id, complete: false, registered: false)","<p>Returns a list of MIME::Type objects, which may be empty. The optional flag\nparameters are <code>:complete</code> …\n"],["[]","MIME::Types","MIME/Types.html#method-c-5B-5D","(type_id, complete: false, registered: false)","<p>MIME::Types#[] against the default MIME::Types registry.\n"],["__instances__","MIME::Types","MIME/Types.html#method-c-__instances__","()",""],["__types__","MIME::Types","MIME/Types.html#method-c-__types__","()",""],["add","MIME::Types","MIME/Types.html#method-c-add","(*types)","<p>MIME::Types#add against the default MIME::Types registry.\n"],["add","MIME::Types","MIME/Types.html#method-i-add","(*types)","<p>Add one or more MIME::Type objects to the set of known types. If the type\nis already known, a warning …\n"],["add_extensions","MIME::Type","MIME/Type.html#method-i-add_extensions","(*extensions)","<p>Merge the <code>extensions</code> provided into this MIME::Type. The\nextensions added will be merged uniquely.\n"],["add_type","MIME::Types","MIME/Types.html#method-i-add_type","(type, quiet = false)","<p>Add a single MIME::Type object to the set of known types. If the\n<code>type</code> is already known, a warning will …\n"],["add_type_variant!","MIME::Types","MIME/Types.html#method-i-add_type_variant-21","(mime_type)",""],["arr","MIME::Types::Columnar","MIME/Types/Columnar.html#method-i-arr","(line)",""],["ascii?","MIME::Type","MIME/Type.html#method-i-ascii-3F","()","<p>MIME types can be specified to be sent across a network in particular\nformats. This method returns <code>false</code> …\n"],["binary?","MIME::Type","MIME/Type.html#method-i-binary-3F","()","<p>MIME types can be specified to be sent across a network in particular\nformats. This method returns <code>true</code> …\n"],["columnar_path","MIME::Types::Loader","MIME/Types/Loader.html#method-i-columnar_path","()",""],["complete?","MIME::Type","MIME/Type.html#method-i-complete-3F","()","<p>Returns <code>true</code> if the MIME::Type specifies an extension list,\nindicating that it is a complete MIME::Type …\n"],["content_type=","MIME::Type","MIME/Type.html#method-i-content_type-3D","(type_string)",""],["count","MIME::Types","MIME/Types.html#method-i-count","()","<p>Returns the number of known type variants.\n"],["count","MIME::Types","MIME/Types.html#method-c-count","()","<p>MIME::Types#count against the default MIME::Types registry.\n"],["default_encoding","MIME::Type","MIME/Type.html#method-i-default_encoding","()","<p>Returns the default encoding for the MIME::Type based on the media type.\n"],["dict","MIME::Types::Columnar","MIME/Types/Columnar.html#method-i-dict","(line, array: false)",""],["each","MIME::Types","MIME/Types.html#method-c-each","()","<p>MIME::Types#each against the default MIME::Types registry.\n"],["each","MIME::Types","MIME/Types.html#method-i-each","()","<p>Iterates through the type variants.\n"],["each_file_line","MIME::Types::Columnar","MIME/Types/Columnar.html#method-i-each_file_line","(name, lookup = true)",""],["encode_with","MIME::Type","MIME/Type.html#method-i-encode_with","(coder)","<p>Populates the <code>coder</code> with attributes about this record for\nserialization. The structure of <code>coder</code> should …\n"],["eql?","MIME::Type","MIME/Type.html#method-i-eql-3F","(other)","<p>Returns <code>true</code> if the <code>other</code> object is a MIME::Type\nand the content types match.\n"],["extensions","MIME::Type","MIME/Type.html#method-i-extensions","()","<p>The list of extensions which are known to be used for this MIME::Type.\nNon-array values will be coerced …\n"],["flag","MIME::Types::Columnar","MIME/Types/Columnar.html#method-i-flag","(line)",""],["friendly","MIME::Type","MIME/Type.html#method-i-friendly","(lang = 'en'.freeze)","<p>A friendly short description for this MIME::Type.\n"],["i18n_key","MIME::Type","MIME/Type.html#method-c-i18n_key","(content_type)","<p>Converts a provided <code>content_type</code> into a translation key\nsuitable for use with the I18n library.\n"],["index_extensions!","MIME::Types","MIME/Types.html#method-i-index_extensions-21","(mime_type)",""],["init_with","MIME::Type","MIME/Type.html#method-i-init_with","(coder)","<p>Initialize an empty object from <code>coder</code>, which must contain the\nattributes necessary for initializing an …\n"],["json_path","MIME::Types::Loader","MIME/Types/Loader.html#method-i-json_path","()",""],["lazy_load?","MIME::Types","MIME/Types.html#method-c-lazy_load-3F","()",""],["like?","MIME::Type","MIME/Type.html#method-i-like-3F","(other)","<p>Indicates that a MIME type is like another type. This differs from\n<code>==</code> because <code>x-</code> prefixes are removed …\n"],["load","MIME::Types::Cache","MIME/Types/Cache.html#method-c-load","(cache_file = nil)","<p>Attempts to load the cache from the file provided as a parameter or in the\nenvironment variable <code>RUBY_MIME_TYPES_CACHE</code> …\n"],["load","MIME::Types::Loader","MIME/Types/Loader.html#method-i-load","(options = { columnar: false })","<p>Loads a MIME::Types registry. Loads from JSON files by default\n(#load_json).\n<p>This will load from columnar …\n"],["load","MIME::Types::Loader","MIME/Types/Loader.html#method-c-load","(options = { columnar: false })","<p>Loads the default MIME::Type registry.\n"],["load_columnar","MIME::Types::Loader","MIME/Types/Loader.html#method-i-load_columnar","()","<p>Loads a MIME::Types registry from columnar files recursively found in\n<code>path</code>.\n"],["load_default_mime_types","MIME::Types","MIME/Types.html#method-c-load_default_mime_types","(mode = load_mode)",""],["load_docs","MIME::Types::Columnar","MIME/Types/Columnar.html#method-i-load_docs","()",""],["load_encoding","MIME::Types::Columnar","MIME/Types/Columnar.html#method-i-load_encoding","()",""],["load_flags","MIME::Types::Columnar","MIME/Types/Columnar.html#method-i-load_flags","()",""],["load_friendly","MIME::Types::Columnar","MIME/Types/Columnar.html#method-i-load_friendly","()",""],["load_from_json","MIME::Types::Loader","MIME/Types/Loader.html#method-c-load_from_json","(filename)","<p>Loads MIME::Types from a single JSON file.\n<p>It is expected that the JSON objects will be an array of hash …\n"],["load_from_yaml","MIME::Types::Loader","MIME/Types/Loader.html#method-c-load_from_yaml","(filename)","<p>Loads MIME::Types from a single YAML file.\n<p>It is expected that the YAML objects contained within the registry …\n"],["load_json","MIME::Types::Loader","MIME/Types/Loader.html#method-i-load_json","()","<p>Loads a MIME::Types registry from JSON files (<code>*.json</code>)\nrecursively found in <code>path</code>.\n<p>It is expected that the …\n"],["load_mode","MIME::Types","MIME/Types.html#method-c-load_mode","()",""],["load_preferred_extension","MIME::Types::Columnar","MIME/Types/Columnar.html#method-i-load_preferred_extension","()",""],["load_use_instead","MIME::Types::Columnar","MIME/Types/Columnar.html#method-i-load_use_instead","()",""],["load_xrefs","MIME::Types::Columnar","MIME/Types/Columnar.html#method-i-load_xrefs","()",""],["load_yaml","MIME::Types::Loader","MIME/Types/Loader.html#method-i-load_yaml","()","<p>Loads a MIME::Types registry from YAML files (<code>*.yml</code> or\n<code>*.yaml</code>) recursively found in <code>path</code>.\n<p>It is expected …\n"],["match","MIME::Type","MIME/Type.html#method-c-match","(content_type)","<p>Return a <code>MatchData</code> object of the <code>content_type</code>\nagainst pattern of media types.\n"],["match","MIME::Types","MIME/Types.html#method-i-match","(pattern)",""],["new","MIME::Type","MIME/Type.html#method-c-new","(content_type)","<p>Builds a MIME::Type object from the <code>content_type</code>, a MIME\nContent Type value (e.g., &#39;text/plain&#39; …\n"],["new","MIME::Types","MIME/Types.html#method-c-new","()","<p>Creates a new MIME::Types registry.\n"],["new","MIME::Types::Loader","MIME/Types/Loader.html#method-c-new","(path = nil, container = nil)","<p>Creates a Loader object that can be used to load MIME::Types registries\ninto memory, using YAML, JSON …\n"],["of","MIME::Types","MIME/Types.html#method-i-of","(filename)",""],["of","MIME::Types","MIME/Types.html#method-c-of","(filename)",""],["opt","MIME::Types::Columnar","MIME/Types/Columnar.html#method-i-opt","(line)",""],["priority_compare","MIME::Type","MIME/Type.html#method-i-priority_compare","(other)","<p>Compares the <code>other</code> MIME::Type based on how reliable it is\nbefore doing a normal &lt;=&gt; comparison. …\n"],["prune_matches","MIME::Types","MIME/Types.html#method-i-prune_matches","(matches, complete, registered)",""],["read_file","MIME::Types::Loader","MIME/Types/Loader.html#method-c-read_file","(filename)",""],["reindex_extensions","MIME::Types","MIME/Types.html#method-c-reindex_extensions","(type)",""],["reindex_extensions!","MIME::Types","MIME/Types.html#method-i-reindex_extensions-21","(mime_type)",""],["save","MIME::Types::Cache","MIME/Types/Cache.html#method-c-save","(types = nil, cache_file = nil)","<p>Attempts to save the types provided to the cache file provided.\n<p>If <code>types</code> is not provided or is <code>nil</code>, the …\n"],["simplified","MIME::Type","MIME/Type.html#method-c-simplified","(content_type, remove_x_prefix: false)","<p>MIME media types are case-insensitive, but are typically presented in a\ncase-preserving format in the …\n"],["simplify_matchdata","MIME::Type","MIME/Type.html#method-c-simplify_matchdata","(matchdata, remove_x = false, joiner: '/'.freeze)",""],["to_h","MIME::Type","MIME/Type.html#method-i-to_h","()","<p>Converts the MIME::Type to a hash. The output of this method can also be\nused to initialize a MIME::Type …\n"],["to_json","MIME::Type","MIME/Type.html#method-i-to_json","(*args)","<p>Converts the MIME::Type to a JSON string.\n"],["to_s","MIME::Type","MIME/Type.html#method-i-to_s","()","<p>Returns the MIME::Type as a string.\n"],["to_str","MIME::Type","MIME/Type.html#method-i-to_str","()","<p>Returns the MIME::Type as a string for implicit conversions. This allows\nMIME::Type objects to appear …\n"],["type_for","MIME::Types","MIME/Types.html#method-c-type_for","(filename)","<p>MIME::Types#type_for against the default MIME::Types registry.\n"],["type_for","MIME::Types","MIME/Types.html#method-i-type_for","(filename)","<p>Return the list of MIME::Types which belongs to the file based on its\nfilename extension. If there is …\n"],["xref_map","MIME::Type","MIME/Type.html#method-i-xref_map","(values, helper)",""],["xref_url_for_draft","MIME::Type","MIME/Type.html#method-i-xref_url_for_draft","(value)",""],["xref_url_for_person","MIME::Type","MIME/Type.html#method-i-xref_url_for_person","(value)",""],["xref_url_for_rfc","MIME::Type","MIME/Type.html#method-i-xref_url_for_rfc","(value)",""],["xref_url_for_rfc_errata","MIME::Type","MIME/Type.html#method-i-xref_url_for_rfc_errata","(value)",""],["xref_url_for_template","MIME::Type","MIME/Type.html#method-i-xref_url_for_template","(value)",""],["xref_urls","MIME::Type","MIME/Type.html#method-i-xref_urls","()","<p>The decoded cross-reference URL list for this MIME::Type.\n"],["yaml_path","MIME::Types::Loader","MIME/Types/Loader.html#method-i-yaml_path","()",""],["Code-of-Conduct","","Code-of-Conduct_rdoc.html","","<p>Contributor Code of Conduct\n<p>As contributors and maintainers of this project, and in the interest of\nfostering …\n"],["Contributing","","Contributing_rdoc.html","","<p>Contributing\n<p>I value any contribution to mime-types you can provide: a bug report, a\nfeature request, …\n"],["History","","History_rdoc.html","","<p>3.0 / 2015-11-21\n<p>2 governance changes\n<p>This project and the related mime-types-data project are now exclusively …\n"],["Licence","","Licence_rdoc.html","","<p>Licence\n<p>Copyright 2003–2015 Austin Ziegler.\n\n<p>The software in this repository is made available under the …\n"],["Manifest","","Manifest_txt.html","","<p>.autotest .gemtest .gitignore .hoerc Code-of-Conduct.rdoc Contributing.rdoc\nHistory.rdoc Licence.rdoc …\n"],["README","","README_rdoc.html","","<p>mime-types for Ruby\n<p>home  &mdash; github.com/mime-types/ruby-mime-types/\n<p>code  &mdash; github.com/mime-types/ruby-mime-types …\n"]]}}